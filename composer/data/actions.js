import { action } from 'mobx'
import { FieldData, RowData, SectionData, TableData, TableRowData, TableCellData, ConstraintData, CalculationData, Module } from './formStore.js'
import { GroupData, FormRef } from './studyStore.js'
import API from '../data/api.js'
import { DialogType } from '../dialogs/dialogTypes.js'
import { DND_Type } from '../interface/dndTypes.js'
import { EditorType } from '../interface/propertiesEditor/editorTypes.js'

class Actions {

  studyStore;
  formStore;

  constructor(formStore, studyStore) {
    console.log("constructor called for actions");
  }

  @action editLabel(newLabel) {
    if(this.isReadonly()) return;
    this.formStore.formLabel = newLabel;
    console.log("edited label: " + newLabel);
  }

  /*
  * Handle websocket refresh messages
  */
  @action refreshView(message){

    if(sessionStorage.tabId === message.tabId){
      console.log("got message from own action, ignoring");
      return;
    }
    console.log("message from server: " + JSON.stringify(message));

    if(message.type === 'form'){
      if(message.uid === this.studyStore.currentForm.id){
        this.navigateToForm(message.uid, true, true);
        this.studyStore.syncNote = "Syncing changes from " + message.userId;
        this.studyStore.showSyncNote = true;
      }
    } else if (message.type === 'study'){
      if(message.uid === this.studyStore.studyData.id){
        API.loadStudy(this.studyStore, this.formStore, message.uid, true, false, true);
        this.studyStore.syncNote = "Syncing changes from " + message.userId;
        this.studyStore.showSyncNote = true;
      }
    } else if (message.type === 'self'){
      
      let formId = this.studyStore.currentForm.id;
      if(!!message.addedFormId){
        formId = message.addedFormId;
      }
      console.log("Processing self message for form: " + formId);
      API.loadStudy(this.studyStore, this.formStore, this.studyStore.studyData.id, true, () => {
        this.navigateToForm(formId, true);
      });
    }
    setTimeout(() => {
      this.studyStore.showSyncNote = false;
    }, 1500)
  }

  /*
   * Dialogs
   */
  @action closeDialog() {
    this.formStore.showDialog = false;
  }

  @action openDialog(type, contents) {
    this.formStore.showDialog = true;
    this.formStore.dialogType = type;
    this.formStore.dialogContents = contents;
  }

  @action openPropertiesEditor(type, data) {
    this.studyStore.showPropertiesEditor = true;
    this.studyStore.propertiesEditorType = type;
    this.studyStore.propertiesEditorData = data;
  }

  @action closePropertiesEditor() {
    this.studyStore.showPropertiesEditor = false;
  }

  @action togglePropertiesEditor(type) {
    if(this.studyStore.showPropertiesEditor){
      this.closePropertiesEditor();
    } else {
      //If the user previously selected a type, use that.  Otherwise use whatever default is passed in.
      let dialogType = !this.studyStore.propertiesEditorType ? type : this.studyStore.propertiesEditorType;
      console.log("Dialog type " + type + " : " + dialogType);
      //Override for group tab
      //if(type === EditorType.GROUP_PROPS) dialogType = type;
      this.openPropertiesEditor(dialogType);
    }
  }
  /*
   * Forms
   */

  @action addGroup(data, callback) {
    if(this.isReadonly(true)) return;
    let group = new GroupData();
    Object.assign(group, data);
    let path = this.studyStore.getPath(this.studyStore.currentView);
    API.addGroup(group, path, (response) => {
      group.id = response.id;
      this.studyStore.currentView.groups.push(group);
      this.navigateToGroup(group.id);
      group.parent = this.studyStore.currentView;
      this.closeDialog();
      if(callback) callback();
    });
  }

  @action updateGroup(data){
    if(this.isReadonly(true)) return;
    console.log("data id: " + data.id);
    let group = this.studyStore.findNode('group', data.id);
    Object.assign(group, data);
    this.saveStudy();
    this.closeDialog();
  }

  /** Adds a form.  The ID is generated by the server to guarantee uniqueness. */
  @action addForm(data, templateId, firstInstance) {
    if(this.isReadonly(true)) return;
    let path = this.studyStore.getPath(this.studyStore.currentGroup);
    API.addForm(data, path, templateId, firstInstance, (response) => {
      this.refreshView({
        type: 'self',
        addedFormId: response.id
      })
      this.closeDialog();
    });
  }

  @action importFormFromJSON(file, formType){
    if(this.isReadonly(true)) return;
    let path = this.studyStore.getPath(this.studyStore.currentGroup);
    path = JSON.stringify(path);
    API.importFormFromJSON(file, path, formType, (response) => {
      this.refreshView({
        type: 'self',
        addedFormId: response.id
      })
      this.closeDialog();
    });
  }

  @action importDictionaryFile(file, callback){
    let formData = this.formStore.formData;
    API.importDictionaryFile(file, formData, callback);
  }

  @action moveFormToGroup(formId, groupId) {
    if(this.isReadonly(true)) return;
    const fromGroup = this.studyStore.findParentNode("formRef", formId);
    const toGroup = this.studyStore.findNode("group", groupId);
    //const form = this.studyStore.findNode("formRef", formId);
    const form = this.removeFromList(fromGroup.formRefs, formId);
    this.studyStore.subMenuKey = Math.random(); //Force the submenu to update @todo: find a better way
    toGroup.formRefs.push(form);
    console.log("moving form from " + fromGroup.id + " to " + toGroup.id);
    //If dragging the current form to a different group, reset currrent form to first in list
    if(this.studyStore.currentForm.id === form.id) {
      this.navigateToGroup(fromGroup.id);
    }
    API.saveStudy(this.studyStore.studyData);
  }

  @action arrangeFormsOrGroups(type, dragId, newIndex) {
    if(this.isReadonly(true)) return;
    let list = type === 'groups' ? this.studyStore.currentView.groups : this.studyStore.currentGroup.formRefs;

    let startIdx = null;
    for(let i = 0; i < list.length; i++) {
      if(list[i].id === dragId) {
        startIdx = i;
      }
    }
    if(startIdx === null) {
      console.log("unable to locate index of " + dragId);
      return;
    }
    //Form didn't move, no need to save
    if(startIdx === newIndex) {
      return;
    }
    var element = list[startIdx];
    list.splice(startIdx, 1);
    list.splice(newIndex, 0, element);
    API.saveStudy(this.studyStore.studyData);
  }
  /*
   * Form Props
   */
  @action editFormProps(obj) {
    if(this.isReadonly()) return;
    let { formData } = this.formStore;
    Object.assign(formData, obj);
    this.saveForm();
  }

  @action changeFormType(type){
    if(this.isReadonly()) return;
    this.studyStore.currentForm.formType = type;
    API.saveStudy(this.studyStore.studyData);
  }

  @action editGroupProps(obj) {
    if(this.isReadonly(true)) return;
    let { currentGroup } = this.studyStore;
    Object.assign(currentGroup, obj);
    API.saveStudy(this.studyStore.studyData);
  }

  @action changeFormState(state){
    API.changeFormState(state, this.studyStore.studyData, this.formStore.formData, this.studyStore.currentForm);
  }

  /**
  Form name and label data is duplicated for faster lookup -- need to update both stores when the name changes
  */
  @action editFormName(name, label) {
    if(this.isReadonly()) return;
    this.formStore.formData.formName = name;
    this.formStore.formData.formLabel = label;
    this.studyStore.currentForm.name = name;
    this.studyStore.currentForm.label = label;
    this.saveForm();
    API.saveStudy(this.studyStore.studyData);
  }

  @action editGroupName(name, label) {
    if(this.isReadonly(true)) return;
    this.studyStore.currentGroup.name = name;
    this.studyStore.currentGroup.label = label;
    API.saveStudy(this.studyStore.studyData);
  }

  @action addOrEditConstraint(constraintData) {
    if(this.isReadonly()) return;
    if(!constraintData.id) {
      let constraint = new ConstraintData();
      Object.assign(constraint, constraintData);
      constraint.id = this.formStore.getUniqueId("constraint", "constraint_");
      this.formStore.formData.constraints.push(constraint);
    } else {
      //Editing an existing constraint
      let constraint = this.formStore.findNode("constraint", constraintData.id);
      Object.assign(constraint, constraintData);
    }
    this.saveForm(() => {
      this.forceFormRefresh();
    });
    this.closeDialog();
  }

  @action addOrEditCalculation(calculationData) {
    if(this.isReadonly()) return;
    if(!calculationData.id) {
      let calc = new CalculationData();
      Object.assign(calc, calculationData);
      calc.id = this.formStore.getUniqueId("calculation", "calculation_");
      this.formStore.formData.calculations.push(calc);
    } else {
      let calc = this.formStore.findNode("calculation", calculationData.id);
      Object.assign(calc, calculationData);
    }
    this.saveForm(() => {
      this.forceFormRefresh();
    });
    this.closeDialog();
  }

  @action removeEditCheck(type, id) {
    if(this.isReadonly()) return;
    if(type === 'constraint') {
      this.removeFromList(this.formStore.formData.constraints, id);
    } else if(type === 'calculation') {
      this.removeFromList(this.formStore.formData.calculations, id);
    }
    this.saveForm();
  }

  @action updateShareRules(elementType, id, shareRules){
    if(this.isReadonly()) return;
    const node = this.formStore.findNode(elementType, id);
    node.shareRules = shareRules;
    this.saveForm();
  }
  /*
   * Form Elements
   */
  @action addField(cellId, fieldData) {
    if(this.isReadonly()) return;
    const cell = this.formStore.findNode('tableCell', cellId);
    if(cell !== null) {
      let field = new FieldData();
      const baseName = fieldData.fieldType === 'label' ? 'form_label_' : 'form_element_';
      let fieldId = this.formStore.getUniqueId("field", baseName);
      let nextIdx = fieldId.substring(13, fieldId.length);
      fieldData.id = fieldId;
      if (fieldData.fieldType !== 'label') {
        /** Label fields do not have an associated 'fieldName'. */
        fieldData.fieldName = !fieldData.fieldName ? "field_" + (Number(nextIdx) + 1) : fieldData.fieldName;
        if(fieldData.fieldType !== 'hidden'){
          fieldData.fieldLabel = !fieldData.fieldLabel ? "Field " + (Number(nextIdx) + 1) : fieldData.fieldLabel;
        } else {
          fieldData.label = "";
        }
      }
      Object.assign(field, fieldData);
      console.log("Added field");
      let componentsCopy = cell.components.slice();
      componentsCopy.push(field);
      cell.components = componentsCopy;
      this.saveForm();

      return field;
    }
  };

  @action addOrEditModule(cellId, moduleData){
    if(this.isReadonly()) return;
    const cell = this.formStore.findNode('tableCell', cellId);
    let module = this.formStore.findNode('module', moduleData.id);
    if(cell !== null && !module) {
      module = new Module();
      let moduleId = this.formStore.getUniqueId("module", "form_module_");
      Object.assign(module, moduleData);
      module.id = moduleId;
      let componentsCopy = cell.components.slice();
      componentsCopy.push(module);
      cell.components = componentsCopy;
    } else if(!!module) {
      console.log("updating existing module: " + JSON.stringify(moduleData))
      Object.assign(module, moduleData);
    }
    this.saveForm();
    this.closeDialog();
  }

  @action copyField(cellId, data, newName, newLabel){
    if(this.isReadonly()) return;
    data.fieldName = newName;
    data.fieldLabel = newLabel;
    this.addField(cellId, data);
    this.closeDialog();
  }

  @action addTable(sectionId, tableData, optionalSection) {
    if(this.isReadonly()) return;
    let section = optionalSection;
    if(!optionalSection) {
      section = this.formStore.findNode('section', sectionId);
    }
    console.log("called add table for section " + sectionId + " and section was " + section);
    if(section) {
      let row = new RowData();
      row.id = this.formStore.getUniqueId("row", "row_");
      let table;
      console.log("updating table id: " + tableData.id);
      if(!tableData.id) { //If no id, then the table is new
        table = new TableData();
        table.id = this.formStore.getUniqueId("table", "table_");
        Object.assign(table, tableData);
        console.log("First col header: " + table.columnHeaders[0]);
        for(let i = 0; i < table.numRows; i++) {
          let tableRow = new TableRowData();
          tableRow.id = table.id + "_row" + i;
          for(let j = 0; j < table.numCols; j++) {
            let tableCell = new TableCellData();
            tableCell.id = tableRow.id + "_cell" + j;
            tableRow.cells.push(tableCell);
            console.log("Added cell: " + tableCell.id);
          }
          table.tableRows.push(tableRow);
        }
        row.tables.push(table);
        section.rows.push(row);
        if(optionalSection) {
          this.formStore.formData.sections.push(section);
        }
        console.log("Added table " + table.id);
        this.saveForm();

      } else { //Editing existing table
        table = this.formStore.findNode("table", tableData.id);
        let numNewCols = tableData.numCols - table.numCols;
        let numNewRows = tableData.numRows - table.numRows;
        if(numNewRows !== 0) {
          if(numNewRows < 0) {
            table.tableRows.length += numNewRows;
          } else {
            this._addTableRows(table, numNewRows, table.numCols);
          }
        }
        if(numNewCols !== 0){
          if(numNewCols < 0){
            for(let i = 0; i < tableData.numRows; i++){
              table.tableRows[i].cells.length += numNewCols;
            }
          } else {
            for(let i = 0; i < tableData.numRows; i++){
              this._addTableCells(table.tableRows[i], numNewCols);
            }
          }
        }
        Object.assign(table, tableData);
        console.log("updated table " + table.id);
        this.saveForm();
      }
    }
  }

  _addTableRows(table, numRows, numCols){
    let startIdx = table.numRows;
    for(let i = 0; i < numRows; i++) {
      let tableRow = new TableRowData();
      tableRow.id = table.id + "_row" + (i + startIdx);
      this._addTableCells(tableRow, numCols)
      table.tableRows.push(tableRow);
    }
  }
  _addTableCells(tableRow, numCells){
      let startIdx = tableRow.cells.length;
      for(let j = 0; j < numCells; j++) {
        let tableCell = new TableCellData();
        tableCell.id = tableRow.id + "_cell" + (j + startIdx);
        tableRow.cells.push(tableCell);
        console.log("Added cell: " + tableCell.id);
      }
  }

  @action addOrEditSection(sectionData) {
    if(this.isReadonly()) return;
    //If this is a new section (has no id yet), then generate one
    if(!sectionData.id) {
      let section = new SectionData();
      Object.assign(section, sectionData);
      section.id = this.formStore.getUniqueId("section", "section_");
      this.closeDialog();
      //Forward on to table creation
      this.openDialog(DialogType.ADD_OR_EDIT_TABLE, { section: section });
    } else {
      //Editing an existing section
      let section = this.formStore.findNode("section", sectionData.id);
      Object.assign(section, sectionData);
      this.closeDialog();
    }
    this.saveForm();
  }

  @action updateTableCell(cellId, cellData) {
    if(this.isReadonly()) return;
    let cell = this.formStore.findNode('tableCell', cellId);
    cell.align = cellData.align;
    cell.layoutOrientation = cellData.layoutOrientation;
    this.saveForm();
  }

  @action updateField(data) {
    if(this.isReadonly()) return;
    let obj = this.formStore.findNode(data._type, data.id);
    const oldName = obj.fieldName;
    const newName = data.fieldName;
    Object.assign(obj, data);
    this.formStore.updateFieldReferences(oldName, newName);
    let fieldType = data.fieldType;
    if(fieldType !== 'select' && fieldType !== 'radio' && fieldType !== 'combo'){
      obj.fieldOptions = [];
      obj.fieldOptionsClass = "";
    }
    if(fieldType !== 'radio' && fieldType !== 'checkbox' && fieldType !== 'hidden'){
      obj.fieldHasInitialValue = false;
      obj.fieldInitialValue = "";
    }
    if(fieldType !== 'combo'){
      obj.comboFileName = "";
    }

    if(fieldType !== 'text' && fieldType !== 'textarea' && fieldType !== 'numeric' && fieldType !== 'integer'){
      obj.fieldPlaceholder = "";
    }
    if(fieldType !== 'vas' && obj.attributes){
      delete obj.attributes.lowValue;
      delete obj.attributes.highValue;
      delete obj.attributes.lowMessage;
      delete obj.attributes.highMessage;
    }
    obj.label = data.label;
    this.closeDialog();
    this.saveForm();
  }

  @action update(data) {
    if(this.isReadonly()) return;
    console.log("Update called with data: " + JSON.stringify(data));
    let obj = this.formStore.findNode(data._type, data.id);
    Object.assign(obj, data);
    obj.label = data.label;
    this.closeDialog();
    this.saveForm();
  }

  /*
   * Sorting and Moving
   */

  @action sortField(cellId, dragId, newIndex) {
    if(this.isReadonly()) return;
    let cell = this.formStore.findNode('tableCell', cellId);
    let components = cell.getChildren();
    let startIdx = null;
    for(let i = 0; i < components.length; i++) {
      if(components[i].id === dragId) {
        startIdx = i;
      }
    }
    if(startIdx === null) {
      console.log("unable to locate index of " + dragId);
      return;
    }
    if(startIdx === newIndex) {
      console.log("field didn't move: old: " + startIdx + " new: " + newIndex);
      return;
    }
    var element = components[startIdx];
    components.splice(startIdx, 1);
    components.splice(newIndex, 0, element);
    console.log("sorted field... old idx: " + startIdx + " new idx: " + newIndex);
    this.saveForm();
  }

  @action moveField(newCellId, oldCellId, fieldId) {
    if(this.isReadonly()) return;
    let oldCell = this.formStore.findNode('tableCell', oldCellId);
    let field = {};
    for(let f of oldCell.components){
      if(f.id === fieldId){
        field = f;
        break;
      }
    }
    let newList = this.removeFromListWithCopy(oldCell.components, fieldId);
    oldCell.components = newList;
    let newCell = this.formStore.findNode('tableCell', newCellId);
    console.log("moving field " + field.id + " from cell " + oldCell.id + ' to new cell ' + newCell.id);
    newList.push(field);
    newCell.components.push(field);
    this.saveForm();
  }

  @action moveElement(parentType, newParentId, oldParentId, id) {
    if(this.isReadonly()) return;
    let oldParent = this.formStore.findNode(parentType, oldParentId);
    let newParent = this.formStore.findNode(parentType, newParentId);
    switch(parentType) {
      case "section":
        let item = this.removeFromList(oldParent.rows, id);
        newParent.rows.push(item);
        break;
    }
    this.saveForm();
  }

  @action moveColumn(tableId, prevIndex, newIndex) {
    if (this.isReadonly()) return;
    // console.log('moving column from ', prevIndex, ' to ', newIndex)
    let table = this.formStore.findNode('table', tableId);

    // reOrder column headers
    if (table.columnHeaders.length > 0) {
      const headerToMove = table.columnHeaders[prevIndex];
      table.columnHeaders.splice(prevIndex, 1);
      table.columnHeaders.splice(newIndex, 0, headerToMove);
    }
    // reOrder column widths
    const widthToMove = table.columnWidths[prevIndex + 1]; // +1 since columnWidths[0] = label column
    table.columnWidths.splice(prevIndex + 1, 1);
    table.columnWidths.splice(newIndex + 1, 0, widthToMove);
    // reOrder columns sort Fields
    let headersSortBy = table.columnHeadersSortBy == null ? [] : table.columnHeadersSortBy;
    let sortByFieldsSize = headersSortBy.length;
    if (sortByFieldsSize > 0 && (sortByFieldsSize > prevIndex || sortByFieldsSize > newIndex)) {
      while (headersSortBy.length <= prevIndex || headersSortBy.length <= newIndex) {
        headersSortBy.push(null);
      }
      const sortToMove = headersSortBy[prevIndex];
      headersSortBy.splice(prevIndex, 1);
      headersSortBy.splice(newIndex, 0, sortToMove);
    }

    // reOrder column data
    for (let row of table.tableRows) {
      const cellToMove = row.cells[prevIndex];
      row.cells.splice(prevIndex, 1);
      row.cells.splice(newIndex, 0, cellToMove);
    }
    this.saveForm();
  }
  @action saveForm(callback){
    API.saveForm(this.formStore.formData, this.studyStore.currentForm.id, callback);
  }

  @action saveStudy(callback){
    API.saveStudy(this.studyStore.studyData, callback);
  }

  @action sortElement(parentType, parentId, dragId, newIndex) {
    if(this.isReadonly()) return;
    console.log("sorting " + parentType + " " + parentId)
    let parent = this.formStore.findNode(parentType, parentId);
    let children = parent.getChildren();
    let startIdx = null;
    for(let i = 0; i < children.length; i++) {
      if(children[i].id === dragId) {
        startIdx = i;
      }
    }
    if(startIdx === null) {
      console.log("unable to locate index of " + dragId);
      return;
    }
    if(startIdx === newIndex) {
      console.log("element didn't move: old: " + startIdx + " new: " + newIndex + " parentId: " + parentId + " dragId: " + dragId);
      return;
    }
    var element = children[startIdx];
    children.splice(startIdx, 1);
    children.splice(newIndex, 0, element);
    console.log("sorted field... old idx: " + startIdx + " new idx: " + newIndex);
    this.saveForm();
  }
  /*
   * Navigation
   */

   /**
    * This gets a little bit confusing.  There is an 'id' for the form ref itself,
    * and then there is a 'refId' which is the id of the 'formDataDoc' that this formRef references.
    * Originally, they shared the same ID, but that caused problems with shared forms.
    * @param {*} id 
    * @param {*} bHideLoading 
    */
  @action navigateToForm(id, bHideLoading, fromWs) {
    console.log("going to form " + id);
    console.log("last form was: " + this.studyStore.currentForm.id);
    const studyId = this.studyStore.studyData.id;
    sessionStorage.setItem("edit_mode_last_view" + studyId, this.studyStore.currentView.id);
    sessionStorage.setItem("edit_mode_last_group" + studyId, this.studyStore.currentGroup.id);
    sessionStorage.setItem("edit_mode_last_form" + studyId, id);

    if(id !== 'placeholder') {
      const formRef = this.studyStore.findNode('formRef', id);
      API.loadForm(this.studyStore, this.formStore, formRef, () => {
        //Restore the current state of the form once the user navigates away
        this.studyStore.currentForm.viewingHistory = undefined;
        this.studyStore.currentForm = this.studyStore.findNode('formRef', id);
        if(this.studyStore.currentForm.formType === 'provided') {
          this.studyStore.propertiesEditorType = EditorType.FORM_DETAILS;
        }
        this.forceFormRefresh();
      }, bHideLoading, fromWs);
    }
  }

  @action navigateToGroup(groupId, optionalForm) {
    console.log('going to group ' + groupId);
    this.studyStore.currentGroup = this.studyStore.findNode('group', groupId);
    if(this.studyStore.currentGroup.formRefs.length < 1) {
      let form = new FormRef();
      this.formStore.formIsLoading = false;
      this.studyStore.currentForm = form;
    } else {
      let formId = this.studyStore.currentGroup.formRefs[0].id;
      if(optionalForm){
        if(this.studyStore.findNode('formRef', optionalForm)){
          formId = optionalForm;
        }
      }
      this.navigateToForm(formId);
    }
  }

  @action navigateToView(view, optionalGroup, optionalForm) {
    console.log('going to view: ' + view);
    this.studyStore.currentView = this.studyStore.findNode('view', view);
    let groupId = this.studyStore.currentView.groups[0].id;
    if(optionalGroup){
      if(this.studyStore.findNode('group', optionalGroup)) {
        groupId = optionalGroup;
      }
    }
    this.navigateToGroup(groupId, optionalForm);
  }

  @action viewFormHistory(revision){
    console.log("called view form history");
     API.loadHistory(this.studyStore, this.formStore, revision);
  }

  @action revertFormToRevision(revision){
    console.log("called revert form history");
    API.revertFormToRevision(this.studyStore, this.formStore, revision);
  }

  @action trash(type, id) {
    if(type !== DND_Type.GROUP && type !== DND_Type.FORM){
      if(this.isReadonly()){
        return;
      }
    }
    if(type === DND_Type.GROUP || type === DND_Type.FORM) {
      let parent = this.studyStore.findParentNode(type, id);
      //Disallow removal of group if there is only one... forms need somewhere to go.
      if(type === DND_Type.GROUP && this.studyStore.currentView.groups.length === 1){
        alert("You must have at least one form group.  If you would like to remove the forms in this group, you may remove them individually.");
        return;
      }
      //If deleting a group, first verify that all forms in the group are in-work
      if(type === DND_Type.GROUP){
        const group = this.studyStore.findNode("group", id);
        const formRefs = group.getChildren();
        for(let i = 0; i < formRefs.length; i++){
          if(formRefs[i].formStatus !== 'in-work'){
            alert("To delete a group, all forms within the group must be in edit mode.")
            return;
          }
        }
      }
      //If deleting a form, check the state of that form specifically
      if(type === DND_Type.FORM){
        const form = this.studyStore.findNode("formRef", id);
        if(form.formStatus !== 'in-work'){
          alert("This form must be in edit mode before it can be deleted");
          return;
        }
      }

      this.removeFromList(parent.getChildren(), id);
      //If deleting the currently viewed group or form, reload the study after save
      //To force the user to a valid form / group
      if((type === DND_Type.GROUP && id === this.studyStore.currentGroup.id)
          || (type === DND_Type.FORM && id === this.studyStore.currentForm.id)){
          console.log("detected deletion of current form");
        this.saveStudy(() => {API.loadStudy(this.studyStore, this.formStore, this.studyStore.studyData.id, false)});
      } else {
        //Otherwise, save the update
        this.saveStudy();
      }
      
    } else {
      let parent = this.formStore.findParentNode(type, id);
      let trash = this.formStore.findNode(type, id);
      let descendantFields = this.formStore.findDescendantFields(trash);
      descendantFields.map((field) => {
        this.formStore.updateFieldReferences(field.fieldName);
      });
      this.removeFromList(parent.getChildren(), id);
      //@todo: Handle removing the 'extra' item due to sorting in a more elegant way.  Right now just using a forced refresh of the form.
      //This leaves a brief flicker of the item before deletion, but is much better than leaving the item there until a manual refresh.
      this.saveForm(() => this.forceFormRefresh());
    }
  }

  removeFromList = function(list, uid) {
    //console.log("trying to remove " + uid + " from list " + list);
    for(var i = 0; i < list.length; i++) {
      if(list[i].id === uid) {
        var row = list[i];
        list.splice(i, 1); //if a match was found, remove it
        return row; //send the removed item back -- may need to add it somewhere
      }
    }
  };

  removeFromListWithCopy(list, uid) {
    let listCopy = list.slice();
    for(var i = 0; i < listCopy.length; i++) {
      if(listCopy[i].id === uid) {
        listCopy.splice(i, 1); //if a match was found, remove it
        return listCopy; //send the removed item back -- may need to add it somewhere
      }
    }
  }

  log(message){
    API.sendLog(message)
  }

  isReadonly(isStudyAction){
    let isReadonly = this.studyStore.readonlyMode;
    if(!_viewOnlyMode && isStudyAction){
      isReadonly = false;
    }
    if(isReadonly){
      alert("This form is currently in read-only mode.  Your changes have not been saved.");
      this.navigateToForm(this.studyStore.currentForm.id);
      this.closeDialog();
      this.closePropertiesEditor();
    }
    return isReadonly;
  }

  /** Should only be used RARELY.  Probably not at all... */
  @action forceFormRefresh(){
    console.log("forcing a refresh")
    this.formStore.refreshId = Math.random();//force a refresh
  }

}
export default new Actions();
